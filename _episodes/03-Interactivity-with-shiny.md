---
# Please do not edit this file directly; it is auto generated.
# Instead, please edit 03-Interactivity-with-shiny.md in _episodes_rmd/
title: Interactivity with Shiny
teaching: 60
exercises: 60
questions:
- "How can I create interactive visualisations?"
objectives:
- "To explain the idea of reactivity in `shiny`"
- "To trace a reactive path through a basic app"
- "To create an interactive app using multiple inputs and outputs"
keypoints:
- "Reactive elements update when their inputs change"
- "Reactive elements can interact with non-reactive elements, but not the other way around"
- "Interactive applications can be broken up into 'UI' and  'server' components"
source: Rmd
---



Creating interactive web applications provides an alternative way of presenting your data. Rather 
than providing a single, predetermined summary of your data, you can instead provide the tools for 
your end users to investigate your data in their own way. 

The basic tools for producing these apps can be found in the [Shiny](http://shiny.rstudio.com) package.
These apps can be extended with a little bit of HTML, CSS or JavaScript, but you **can** create a 
fully functional app using only R code.

# Reactivity in Shiny

Creating these interactive applications will involve a pretty large conceptual shift however, because
it 'breaks' the way we have learned R behaves.

> ## Standard behaviour
> 
> Consider the following lines of code: 
> 
> ~~~~~
> a <- 10
> b <- a + 5
> 
> b
> 
> a <- 20
> 
> b
> ~~~~~
> {: .language-r}
> What is the value of `b` each time it is printed?
> > ## Solution
> > `b` is 15 both times.
> {: .solution}
{: .challenge}


In a traditional environment, when R creates a variable from an expression it determines the value of
that variable at the time of assignment and stores it. Once stored, the variable loses any connection
to the values were used to create it. So in the example above, once the value of `b` has been set the
value of `a` can be changed without any effect on `b`.

The Shiny framework provides a *reactive* environment, in which inputs and outputs can be linked 
together, allowing them to all update in response to changes. Conceptually, the above example running
in a reactive environment would result in:

~~~~~
a <- 10
b <- a + 5
 
b
~~~~~
{: .language-r}
~~~~~
[1] 15
~~~~~
{: .output}
~~~~~
a <- 20

b
~~~~~
{: .language-r}
~~~~~
[1] 25
~~~~~
{: .output}

The variable `b` now updates its value in response to changes in `a`. Shiny handles the process of 
creating this interactivity in the background, and you can read more about it
[here](http://shiny.rstudio.com/articles/understanding-reactivity.html). From our perspective however,
changes to one value in our code will appear to flow on to other parts of code that depend on them.

The one limitation that Shiny imposes on our code is that any elements you create within a reactive
environment cannot be accessed by elements in the traditional environment. Since the value of a 
reactive element is not fixed, it is impossible for traditional evaluation to occur. The opposite is 
not true however, reactive elements can access other reactive elements as well as those in the 
traditional environment.

# An app in two halves

When writing a Shiny app, your code will be broken up into two separate parts. 

### UI 
The first is the user interface of the app. This contains all of the inputs that your end user will 
be able to control, and the outputs that they will see. The final result of your UI code is a single
HTML page that can be opened in a web browser.

### Server
The second is the server logic of the app. This is what will run your code in response to user input,
and create the outputs to provide to the user. This part of the code requires an active R session to
function properly, which means you need to find a way to host your app if you want to make it accessible
to other people.

# Creating an app

Shiny comes with a number of inbuilt example applications that can be run from the R console. We'll
explore one of these before we start diving in to creating your own

> ## The end product
> The first example app can be run with:
> ~~~~~
> library(shiny)
> runExample("01_hello")
> ~~~~~
> {: .language-r}
> Explore this basic example and list the reactive, and non-reactive elements you can find. Can you 
> further classify the reactive elements as inputs or outputs?
> 
> You have been interacting with the UI half of the example application. What do you think is 
> happening in the server half?
{: .challenge}

Creating a Shiny app of your own can be done within RStudio by creating a new Project in a fresh 
directory. At the Project Type window, select Shiny Web Application.
![]({{ page.root }}/fig/new_app.png){:class="fig-responsive" style="max-width:50%"}

This creates a skeleton application with the code from the example we just looked at. To run this 
app again, click the Run App button in the top corner of the code editor pane ![]({{page.root}}/fig/run_app.png){:class="fig-responsive" style="display: inline-block; max-height:20px"}.

> ## Exploring an app
> Run the default app created when you set up the project and confirm that it has the same function
> as the example app run previously.
>
> Look through the the code of the app to identify:
> 
> * The UI and the server code
> * The UI inputs and outputs you identified in the previous exercise
> * How those inputs and outputs are referred to in the server
> 
> **Hint:** Searching the file (<kbd>Ctrl</kbd>+<kbd>F</kbd>) for 'input' and 'output' will help with
> the last two parts if you are stuck.
>
> > ## Solution
> > 
> > * **UI:** lines 13--33, **Server:** lines 36--46
> > * **Number of bins input slider:** lines 21--25, **Plot output:** line 30
> > * **Input slider:** line 41 (`input$bins`), **Output plot:** lines 38--45 (`output$distPlot`)
> > 
> {: .solution}
{: .challenge}

UI
	Inputs:
		sliderInput("bins", ...)
	Outputs:
		plotOutput("distPlot")
Server
	Inputs:
		input$bins
	Outputs:
		output$distPlot


Show the reactivity links?

## Inputs
Different types of UI inputs (use gallery?)

Note different things being stored in input$XXXX

##Outputs
Outputs created by renderXXX functions and stored in output$XXXX

Different types of outputs

##Generic reactives
Sometimes, need a reactive that's not directly linked to an input/output
Eg. Select year, plot data from that year in two different ways

Want: input$year -> data %>% filter(year) 	-> plot1
						                                -> plot2

Slow to filter it for each one. Wrap the filter result in a reactive function, produces a reactive variable

## Organising an app
